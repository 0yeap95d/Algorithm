# ì˜¤ì¼ëŸ¬ ê²½ë¡œì™€ íšŒë¡œ (Eulerian Trail & Circuit)



### ðŸ” ì˜¤ì¼ëŸ¬ ê²½ë¡œì™€ íšŒë¡œëž€?

> - **ì˜¤ì¼ëŸ¬ ê²½ë¡œ**ëž€ ê·¸ëž˜í”„ì— ì¡´ìž¬í•˜ëŠ” ëª¨ë“  Edgeë¥¼ ì •í™•ížˆ 1ë²ˆì”©ë§Œ ë°©ë¬¸í•˜ëŠ” ì—°ì†ëœ ê²½ë¡œ
> - ì´ë•Œ ì‹œìž‘ì ê³¼ ë„ì°©ì ì´ ê°™ìœ¼ë©´ **ì˜¤ì¼ëŸ¬ íšŒë¡œ(Circuit)** ë¼ê³  í•¨
> - ê°„ë‹¨í•˜ê²Œ í•œë¶“ê·¸ë¦¬ê¸°ë¥¼ ìƒê°í•˜ë©´ ë¨



### ðŸ’¡ ì˜¤ì¼ëŸ¬ ê²½ë¡œ íŒë‹¨

>- ëª¨ë“  ê°„ì„ ì´ ë‹¨ í•˜ë‚˜ì˜ ê·¸ëž˜í”„ì— ì—°ê²°ë˜ì–´ ìžˆì„ ë•Œ
>- ë¬´í–¥ ê·¸ëž˜í”„ì¼ ê²½ìš° Degreeê°€ **í™€ìˆ˜ì¸ ì •ì ì´ 2ê°œ**ì¼ë•Œ **ì˜¤ì¼ëŸ¬ ê²½ë¡œ** ì¡´ìž¬
>- ìœ í–¥ ê·¸ëž˜í”„ì¼ ê²½ìš° 
>    - ì‹œìž‘ì ì˜ **in_degree + 1 = out_degree**
>    - ëì ì˜ **in_degree = out_degree + 1**
>    - ë‚˜ë¨¸ì§€ ì ì˜ **in_degree = out_degree**



### ðŸ’¡ ì˜¤ì¼ëŸ¬ íšŒë¡œ íŒë‹¨

>- ëª¨ë“  ê°„ì„ ì´ ë‹¨ í•˜ë‚˜ì˜ ê·¸ëž˜í”„ì— ì—°ê²°ë˜ì–´ ìžˆì„ ë•Œ
>- ë¬´í–¥ ê·¸ëž˜í”„ì¼ ê²½ìš° Degreeê°€ **í™€ìˆ˜ì¸ ì •ì ì´ 0ê°œ**ì¼ë•Œ **ì˜¤ì¼ëŸ¬ íšŒë¡œ** ì¡´ìž¬
>- ìœ í–¥ ê·¸ëž˜í”„ì¼ ê²½ìš° ëª¨ë“  ì •ì ì˜ **in_degreeì™€ out_degreeê°€ ê°™ì„ ë•Œ**



### ðŸ”‘ Hierholzer's Algorithm êµ¬í˜„

>- ####  ì˜¤ì¼ëŸ¬ íšŒë¡œë¥¼ ì°¾ëŠ” ë°©ë²•
>
>  1. ìž„ì˜ì˜ ê·¸ëž˜í”„ ë‚´ì˜ ì‹œìž‘ì  uë¥¼ ì •í•œë‹¤
>  2. ì‹œìž‘ì  uì— ëŒ€í•´ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê°„ì„  (u, v)ì´ ìžˆë‹¤ë©´ ê·¸ ê°„ì„ ì„ ë”°ë¼ ì´ë™í•œë‹¤.
>  3. ì´ë™í•˜ì—¬ ë„ì°©í•œ ì •ì  vì— ëŒ€í•´ì„œ ë˜ ë‹¤ì‹œ 2ë²ˆê³¼ ê°™ì´ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê°„ì„ ì´ ìžˆë‹¤ë©´ ë”°ë¼ì„œ ì´ë™í•œë‹¤.
>  4. 3ë²ˆì„ ë°˜ë³µí•˜ë‹¤ê°€ ë” ì´ìƒ ì´ë™ í•  ê°„ì„ ì´ ì—†ë‹¤ë©´ ì´ë•Œê¹Œì§€ ì´ë™í•˜ì˜€ë˜ ê²½ë¡œë¥¼ ë°˜í™˜í•œë‹¤.
>  5. ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê°„ì„ ì— ëŒ€í•´ 3ë²ˆì„ ë°˜ë³µ ìˆ˜í–‰í•˜ê³  ì–»ì–´ì§€ëŠ” ê²½ë¡œë¥¼ ëª¨ë‘ í•©ì¹œë‹¤.
>
>```c++
>#include<iostream>
>#include<vector>
>#include<algorithm>
>
>using namespace std;
>
>vector< vector<int> > adj;
>vector<int> euler;
>
>/* DFSì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ê²½ë¡œë¥¼ ì°¾ì•„ê°‘ë‹ˆë‹¤. */
>void findEulerianCircuit(int here) {
>   for (int there = 1; there < adj.size(); there++) {
>       while (adj[here][there] > 0) {
>           adj[here][there]--;
>           adj[there][here]--;
>           findEulerianCircuit(there);
>       }
>   }
>   euler.push_back(here);
>}
>
>int main() {
>   adj = vector< vector<int> >(8, vector<int>(8, 0));
>   euler.clear();
>   adj[1][2] = adj[2][1] = 1;
>   adj[2][5] = adj[5][2] = 1;
>   adj[4][5] = adj[5][4] = 1;
>   adj[3][4] = adj[4][3] = 1;
>   adj[3][1] = adj[1][3] = 1;
>   adj[5][7] = adj[7][5] = 1;
>   adj[6][7] = adj[7][6] = 1;
>   adj[5][6] = adj[6][5] = 1;
>   findEulerianCircuit(1);
>   reverse(euler.begin(), euler.end());
>   for (int v : euler) {
>       cout << v << " ";
>   }
>   cout << '\n';
>}
>```

>- #### ì˜¤ì¼ëŸ¬ ê²½ë¡œë¥¼ ì°¾ëŠ” ë°©ë²•
>
>  1. ì‹œìž‘ì ê³¼ ëì ì„ ì˜¤ì¼ëŸ¬ íšŒë¡œê°€ ì¡´ìž¬í•˜ê²Œë” ê°„ì„ ìœ¼ë¡œ ì´ì–´ì¤€ë‹¤.
>  2. ì˜¤ì¼ëŸ¬ íšŒë¡œë¥¼ ì°¾ëŠ”ë‹¤.
>  3. ì°¾ì€ ê²½ë¡œì—ì„œ 1ì—ì„œ ì¶”ê°€í•œ ê°„ì„ ì„ ì‚­ì œí•œë‹¤



### ðŸ“š ì°¸ê³ ìžë£Œ

>- [ì˜¤ì¼ëŸ¬ ê²½ë¡œì™€ íšŒë¡œ](https://rain-bow.tistory.com/entry/%EC%98%A4%EC%9D%BC%EB%9F%AC-%EA%B2%BD%EB%A1%9C%EC%99%80-%ED%9A%8C%EB%A1%9CEulerian-trail-circuit)
>- [ì•Œê³ ë¦¬ì¦˜ ê³µë¶€ í•œë¶“ê·¸ë¦¬ê¸°](https://sonsh0824.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B3%B5%EB%B6%804-%ED%95%9C%EB%B6%93%EA%B7%B8%EB%A6%AC%EA%B8%B0Eulerian-circuit)